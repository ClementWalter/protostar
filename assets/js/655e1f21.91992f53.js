"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[403],{3905:function(e,t,n){n.d(t,{Zo:function(){return c},kt:function(){return d}});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function s(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?s(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},s=Object.keys(e);for(a=0;a<s.length;a++)n=s[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(a=0;a<s.length;a++)n=s[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),u=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},c=function(e){var t=u(e.components);return a.createElement(l.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,s=e.originalType,l=e.parentName,c=o(e,["components","mdxType","originalType","parentName"]),m=u(n),d=r,h=m["".concat(l,".").concat(d)]||m[d]||p[d]||s;return n?a.createElement(h,i(i({ref:t},c),{},{components:n})):a.createElement(h,i({ref:t},c))}));function d(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var s=n.length,i=new Array(s);i[0]=m;var o={};for(var l in t)hasOwnProperty.call(t,l)&&(o[l]=t[l]);o.originalType=e,o.mdxType="string"==typeof e?e:r,i[1]=o;for(var u=2;u<s;u++)i[u]=n[u];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},1548:function(e,t,n){n.r(t),n.d(t,{assets:function(){return c},contentTitle:function(){return l},default:function(){return d},frontMatter:function(){return o},metadata:function(){return u},toc:function(){return p}});var a=n(7462),r=n(3366),s=(n(7294),n(3905)),i=["components"],o={},l="Fuzzing",u={unversionedId:"tutorials/testing/fuzzing/README",id:"tutorials/testing/fuzzing/README",title:"Fuzzing",description:"This feature is actively developed and many new additions will land in future Protostar releases.",source:"@site/docs/tutorials/07-testing/03-fuzzing/README.md",sourceDirName:"tutorials/07-testing/03-fuzzing",slug:"/tutorials/testing/fuzzing/",permalink:"/protostar/docs/tutorials/testing/fuzzing/",editUrl:"https://github.com/software-mansion/protostar/tree/master/website/docs/tutorials/07-testing/03-fuzzing/README.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorials",previous:{title:"warp",permalink:"/protostar/docs/tutorials/testing/cheatcodes/warp"},next:{title:"Reproducing failures",permalink:"/protostar/docs/tutorials/testing/fuzzing/reproducing-failures"}},c={},p=[{value:"Example",id:"example",level:2},{value:"The <em>Safe</em>",id:"the-safe",level:3},{value:"Unit testing",id:"unit-testing",level:3},{value:"Generalizing the test",id:"generalizing-the-test",level:3},{value:"Fixing the bug",id:"fixing-the-bug",level:3},{value:"Interpreting results",id:"interpreting-results",level:2},{value:"Adjusting fuzzing quality",id:"adjusting-fuzzing-quality",level:2}],m={toc:p};function d(e){var t=e.components,n=(0,r.Z)(e,i);return(0,s.kt)("wrapper",(0,a.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,s.kt)("h1",{id:"fuzzing"},"Fuzzing"),(0,s.kt)("div",{className:"admonition admonition-warning alert alert--danger"},(0,s.kt)("div",{parentName:"div",className:"admonition-heading"},(0,s.kt)("h5",{parentName:"div"},(0,s.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,s.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,s.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M5.05.31c.81 2.17.41 3.38-.52 4.31C3.55 5.67 1.98 6.45.9 7.98c-1.45 2.05-1.7 6.53 3.53 7.7-2.2-1.16-2.67-4.52-.3-6.61-.61 2.03.53 3.33 1.94 2.86 1.39-.47 2.3.53 2.27 1.67-.02.78-.31 1.44-1.13 1.81 3.42-.59 4.78-3.42 4.78-5.56 0-2.84-2.53-3.22-1.25-5.61-1.52.13-2.03 1.13-1.89 2.75.09 1.08-1.02 1.8-1.86 1.33-.67-.41-.66-1.19-.06-1.78C8.18 5.31 8.68 2.45 5.05.32L5.03.3l.02.01z"}))),"warning")),(0,s.kt)("div",{parentName:"div",className:"admonition-content"},(0,s.kt)("p",{parentName:"div"},"This feature is actively developed and many new additions will land in future Protostar releases."))),(0,s.kt)("p",null,"Protostar tests can take parameters, which makes such tests to be run in a ",(0,s.kt)("em",{parentName:"p"},"fuzzing mode"),".\nIn this mode, Protostar treats the test case parameters as a specification of the test case,\nin the form of properties which it should satisfy,\nand tests that these properties hold in numerous randomly generated input data."),(0,s.kt)("p",null,"This technique is often called ",(0,s.kt)("em",{parentName:"p"},"property-based testing"),".\nFrom the perspective of a user, the purpose of property-based testing is to make it easier for the\nuser to write better tests."),(0,s.kt)("h2",{id:"example"},"Example"),(0,s.kt)("h3",{id:"the-safe"},"The ",(0,s.kt)("em",{parentName:"h3"},"Safe")),(0,s.kt)("p",null,'Let\'s see how fuzzing works in Protostar, by writing a test for an abstract "safe":'),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cairo",metastring:'title="src/main.cairo"',title:'"src/main.cairo"'},'%lang starknet\nfrom starkware.cairo.common.math import assert_nn\nfrom starkware.cairo.common.cairo_builtins import HashBuiltin\n\n@storage_var\nfunc balance() -> (res: felt) {\n}\n\n@external\nfunc withdraw{\n    syscall_ptr: felt*,\n    pedersen_ptr: HashBuiltin*,\n    range_check_ptr\n}(amount: felt) {\n    if (amount == 0) {\n        return ();\n    }\n\n    let (res) = balance.read();\n    let new_res = res - amount;\n\n    with_attr error_message("Cannot withdraw more than stored.") {\n        assert_nn(new_res);\n    }\n\n    balance.write(new_res);\n    return ();\n}\n\n@constructor\nfunc constructor{\n    syscall_ptr: felt*,\n    pedersen_ptr: HashBuiltin*,\n    range_check_ptr\n}() {\n    balance.write(10000);\n    return ();\n}\n')),(0,s.kt)("h3",{id:"unit-testing"},"Unit testing"),(0,s.kt)("p",null,"Let's first verify this function by writing a unit test in order to find the general property we are\ntesting for:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cairo",metastring:'title="tests/test_main.cairo"',title:'"tests/test_main.cairo"'},"%lang starknet\nfrom src.main import balance, withdraw\nfrom starkware.cairo.common.cairo_builtins import HashBuiltin\n\n@external\nfunc test_withdraw{\n    syscall_ptr: felt*,\n    pedersen_ptr: HashBuiltin*,\n    range_check_ptr\n}() {\n    alloc_locals;\n    let (pre_balance_ref) = balance.read();\n    local pre_balance = pre_balance_ref;\n\n    let amount = 1;\n\n    withdraw(amount);\n\n    let (post_balance) = balance.read();\n    assert post_balance = pre_balance - amount;\n\n    return ();\n}\n")),(0,s.kt)("p",null,"So far, so good. Running the test, we see it passes:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-text",metastring:'title="$ protostar test"',title:'"$',protostar:!0,'test"':!0},"[PASS] tests/test_main.cairo test_withdraw (steps=129)\n       range_check_builtin=1\n\n11:28:43 [INFO] Test suites: 1 passed, 1 total\n11:28:43 [INFO] Tests:       1 passed, 1 total\n")),(0,s.kt)("h3",{id:"generalizing-the-test"},"Generalizing the test"),(0,s.kt)("p",null,'This unit test performs checks if we can withdraw "some" amount from our safe.\nHowever, can we be sure that it works for all amounts, not just this particular one?'),(0,s.kt)("p",null,"The general property here is: given a safe balance, when we withdraw some amount from it,\nwe should get reduced balance in the safe, and it should not be possible to withdraw more than we\nhave."),(0,s.kt)("p",null,"Protostar will run any test that takes parameters in fuzz testing mode, so let's rewrite our unit\ntest.\nWe need to take the ",(0,s.kt)("inlineCode",{parentName:"p"},"Cannot withdraw more than stored.")," error, so we also add a call to\nthe ",(0,s.kt)("a",{parentName:"p",href:"/protostar/docs/tutorials/testing/cheatcodes/expect-revert"},(0,s.kt)("inlineCode",{parentName:"a"},"expect_revert"))," cheatcode if needed."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cairo",metastring:'title="tests/test_main.cairo"',title:'"tests/test_main.cairo"'},'@external\nfunc test_withdraw{\n    syscall_ptr: felt*,\n    pedersen_ptr: HashBuiltin*,\n    range_check_ptr\n}(amount: felt) {\n    alloc_locals;\n    let (pre_balance_ref) = balance.read();\n    local pre_balance = pre_balance_ref;\n\n    %{\n        if ids.amount > ids.pre_balance:\n            expect_revert(error_message="Cannot withdraw more than stored.")\n    %}\n    withdraw(amount);\n\n    let (post_balance) = balance.read();\n    assert post_balance = pre_balance - amount;\n\n    return ();\n}\n')),(0,s.kt)("p",null,"If we run the test now, we can see that Protostar runs a fuzz test, but it fails for high values\nof ",(0,s.kt)("inlineCode",{parentName:"p"},"amount"),":"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-text",metastring:'title="$ protostar test"',title:'"$',protostar:!0,'test"':!0},"[FAIL] tests/test_main.cairo test_withdraw\n[type] TRANSACTION_FAILED\n[code] 39\n[messages]:\n\u2014 Cannot withdraw more than stored.\n[details]:\n<REDACTED>/starkware/cairo/common/math.cairo:40:5: Error at pc=0:0:\nGot an exception while executing a hint.\n    %{\n    ^^\nCairo traceback (most recent call last):\ntests/test_main.cairo:22:6: (pc=0:141)\nfunc test_withdraw(\n     ^***********^\ntests/test_main.cairo:36:5: (pc=0:125)\n    withdraw(amount);\n    ^***************^\nError message: Cannot withdraw more than stored.\n<REDACTED>/src/main.cairo:23:9: (pc=0:63)\n        assert_nn(new_res);\n        ^*****************^\n\nTraceback (most recent call last):\n  File \"<REDACTED>/starkware/cairo/common/math.cairo\", line 43, in <module>\n    assert 0 <= ids.a % PRIME < range_check_builtin.bound, f'a = {ids.a} is out of range.'\nAssertionError: a = 3618502788666131213697322783095070105282824848410658236509717448704103819025 is out of range.\n[falsifying example]:\namount = 340282366920938463463374607431768211456\n\n11:41:48 [INFO] Test suites: 1 failed, 1 total\n11:41:48 [INFO] Tests:       1 failed, 1 total\n11:41:48 [INFO] Seed:        4258368192\n")),(0,s.kt)("h3",{id:"fixing-the-bug"},"Fixing the bug"),(0,s.kt)("p",null,"The test fails because ",(0,s.kt)("inlineCode",{parentName:"p"},"amount")," has ",(0,s.kt)("inlineCode",{parentName:"p"},"felt")," type so its value can be negative. If smallest possible ",(0,s.kt)("inlineCode",{parentName:"p"},"felt")," value is subtracted from ",(0,s.kt)("inlineCode",{parentName:"p"},"balance")," it causes ",(0,s.kt)("inlineCode",{parentName:"p"},"felt")," overflow.\nThe solution, is to check if ",(0,s.kt)("inlineCode",{parentName:"p"},"amount")," is a negative number in ",(0,s.kt)("inlineCode",{parentName:"p"},"withdraw"),", and adjust ",(0,s.kt)("inlineCode",{parentName:"p"},"test_withdraw"),"\nappropriately:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cairo",metastring:'title="src/main.cairo"',title:'"src/main.cairo"'},'@external\nfunc withdraw{\n    syscall_ptr: felt*,\n    pedersen_ptr: HashBuiltin*,\n    range_check_ptr\n}(amount: felt) {\n    with_attr error_message("Amount must be positive.") {\n        assert_nn(amount);\n    }\n\n    // ...\n}\n')),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cairo",metastring:'title="tests/test_main.cairo"',title:'"tests/test_main.cairo"'},'@external\nfunc test_withdraw{\n    syscall_ptr: felt*,\n    pedersen_ptr: HashBuiltin*,\n    range_check_ptr\n}(amount: felt) {\n    // ...\n\n    %{\n        if not (0 <= ids.amount and ids.amount % PRIME < range_check_builtin.bound):\n            expect_revert(error_message="Amount must be positive.")\n        elif ids.amount > ids.pre_balance:\n            expect_revert(error_message="Cannot withdraw more than stored.")\n    %}\n    withdraw(amount);\n\n    // ...\n}\n')),(0,s.kt)("p",null,"And now, the test passes.\nWe can also observe the variance of resources usage, caused by the ",(0,s.kt)("inlineCode",{parentName:"p"},"if amount == 0:")," branch in code."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-text",metastring:'title="$ protostar test"',title:'"$',protostar:!0,'test"':!0},"[PASS] tests/test_main.cairo test_withdraw (fuzz_runs=100, steps=\u03bc: 127, Md: 137, min: 84, max: 137)\n       range_check_builtin=\u03bc: 1.81, Md: 2, min: 1, max: 2\n\n11:55:18 [INFO] Test suites: 1 passed, 1 total\n11:55:18 [INFO] Tests:       1 passed, 1 total\n11:55:18 [INFO] Seed:        3741774783\n")),(0,s.kt)("h2",{id:"interpreting-results"},"Interpreting results"),(0,s.kt)("p",null,"In fuzzing mode, the test is executed many times, hence test summaries are extended:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},"[PASS] tests/test_main.cairo test_withdraw (fuzz_runs=100, steps=\u03bc: 127, Md: 137, min: 84, max: 137)\n       range_check_builtin=\u03bc: 1.81, Md: 2, min: 1, max: 2\n")),(0,s.kt)("p",null,"Each resource counter presents a summary of observed values across all test runs:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"\u03bc")," is the mean value of a used resource,"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"Md")," is the median value of this resource,"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"min")," is the lowest value observed,"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"max")," is the highest value observed.")),(0,s.kt)("h2",{id:"adjusting-fuzzing-quality"},"Adjusting fuzzing quality"),(0,s.kt)("p",null,"By default, Protostar tries to fail a test case within 100 examples.\nThe default value is chosen to suit a workflow where the test will be part of a suite that is\nregularly executed locally or on a CI server,\nbalancing total running time against the chance of missing a bug.\nThe more complex code, the more examples are needed to find uncommon bugs.\nTo adjust number of input cases generated by the fuzzer,\ncall the ",(0,s.kt)("a",{parentName:"p",href:"/protostar/docs/tutorials/testing/cheatcodes/max-examples"},(0,s.kt)("inlineCode",{parentName:"a"},"max_examples"))," cheatcode within a\n",(0,s.kt)("a",{parentName:"p",href:"/protostar/docs/tutorials/testing/#setup-hooks"},"setup hook"),"."))}d.isMDXComponent=!0}}]);